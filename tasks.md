## Тестовое задание TradeLink

Задачи можно выполнять на JavaScript (в среде Node.js) или Python, 
какой вам покажется более подходящим под задачу. 
Использование Typescript, MyPy приветствуется, сам проект с решениями должен 
устанавливаться обычными `pip instal -i requirements.txt` или `npm install`, 
проекты на разных языках лучше разделить в отдельные директории, 
в README.md укажите версии python, pip, node, npm и инструкцию по запуску. 
На каждом языке Python или JS (TS) должно быть написано решение 
хотя бы одной из задач, то есть использовать только один язык 
для решения всех задач не допускается.
Написание тестов приветствуется.

Из раздела `А` нужно решить обе задачи, из раздела `B` достаточно одну, задача `C` опциональная,
но её решение будет огромным плюсом. При решении каждой задачи необходимо привести 
максимально возможное, асимптотически оптимальное по памяти и времени решение. 
В задачах раздела `B` в большей степени оценивается дизайн кода и реализация.

Во всех случаях подразумевающих ввод/вывод, предполагается stdin/stdout. 
При решении задач нельзя пользоваться дополнительными библиотеками, 
только средствами языка и стандартной библиотекой.
Для тестов разрешается использовать любую библиотеку.

### A1. Скобки

На вход подается строка состоящая из различных символов в пределах ASCII,
скобками считаются символы `()[]{}`, все что не является скобками, 
считается некоторыми корректными частями выражения. 
Строка является корректным выражением, если все скобки в нем корректно закрываются, 
то есть каждая закрывающая скобка закрывает последнюю открытую скобку исключительно своего типа,
иначе это некорректно, открывающим скобкам `(, [, {` соответствуют закрывающие `), ], }`.
Например выражение `(123[abc]45)` является корректным, а выражение `([abc)]` – нет.
Необходимо на вывод вывести `Correct`, если строка является корректным выражением и `Incorrect`, 
если не является.

#### Пример
Ввод
```
([abc])
```
Вывод
```
Correct
```

### A2. (Не) Фибоначчи

Числа Фибоначчи (https://ru.wikipedia.org/wiki/Числа_Фибоначчи) образуют 
неубывающую последовательность:

0, 1, 1, 2, 3, 5, 8, 13, 21, ... 

Числами не Фибоначчи будем называть последовательность чисел, 
которые не входят в последовательность чисел Фибоначчи: 

4, 6, 7, 9, 10, 11, 12, 14, ...

Требуется написать **бесконечный генератор** последовательности чисел не Фибоначчи.
На вход подается число N, означающее количество чисел, которое необходимо вывести на вывод,
каждое в отдельной строке.

#### Пример
Ввод
```
5
```
Вывод
```
4
6
7
9
10
```

### B1. LRU

Кэш с политикой Least Recently Used используется для отбрасывания из памяти элементов, 
которые по логическому времени использовались в достаточной степени давно,
назовем это счетчиком давности.
Запрос некоторого ключа (равно как и добавление нового) 
обнуляет счетчик давности этого ключа и увеличивает на 1 счетчик давности 
всех существующих ключей в кэше, кроме запрошенного.
Те ключи, чей счетчик давности больше чем max_size (задается параметром для кэша) – 
выбрасываются из кэша.
Необходимо реализовать класс для LRU кэша, класс должен уметь принимать 
параметр максимального размера кэша при инициализации, 
должен предоставлять проксирующий метод, 
который принимает на вход ключ, функцию и её аргументы.
Если значение по ключу есть в кэше, то метод не вызывает функцию, а возвращает значение из кэша, 
если такой ключ отсутствует в кэше, то выполняется функция с переданными аргументами,
её результат записывается в кэш и возвращается.
При решении этой задачи нельзя пользоваться готовыми структурами данных, 
которые предоставляет язык, кроме тривиальных, проще говоря – здесь запрещается 
использовать стандартную библиотеку, то есть какие-либо import или require кроме собственного кода. 
Дополнительно для питона: решение должно быть совместимым с Python 3.5
Дополнительно для nodejs: нельзя пользоваться свойством insertion порядка ключей в Map (А в Object спецификацией и не гарантируется)

### B2. Счетчик

Счетчик количества запросов используется для определения RPS (Requests Per Second), например.
В общем случае хотелось бы считать что-то иное количественное за заданный промежуток времени, 
например вес запросов за минуту, которые поступают в API, если запросы разной сложности.
Важно заметить, что необходимый промежуток времени постоянно сдвигается, 
и просто считать запросы за какой-то предыдущий фиксированный промежуток – не подходит.
Здесь необходимо реализовать обобщенный класс, инициализирующийся параметром промежутка времени, 
за который ведется подсчет, который имеет метод hit, принимающий аргументом значение, 
на которое увеличивается счетчик, и метод count, возвращающий текущее значение счетчика.
Запросов может быть очень много, поэтому здесь нужно выбрать оптимальное 
соотношение между точностью и ресурсами, которые будет потреблять такая структура, 
скажем, если счетчик считает за минуту (60 секунд), 
допустима погрешность/отставание в районе 3 секунд (то есть 1/20 интервала). 

### C. Разделяй и властвуй

На вход подается число `N`, затем подается `N` слов состоящих из латинских символов.
Эти слова образуют известный нам словарь некоторого языка.
Далее на вход подается число `K`, затем подается `K` строк, состоящих из латинских символов.
Необходимо проверить, является ли строка конкатенацией ровно двух известных слов.
На вывод на каждую строку возвращается количество всех возможных конкатенаций, 
а затем сами варианты разделения в любом порядке через пробел, в месте разделения ставится двоеточие.
Здесь предполагается, что `K` достаточно большое, 
чтобы требовать от алгоритма максимально возможной скорости выполнения, 
ценой, возможно, дополнительной памяти.

#### Пример
Ввод
```
5
abcd
cdef
ab
ef
ffff
2
abcdef
ffff
```
Вывод
```
2 abcd:ef ab:cdef
0
```
